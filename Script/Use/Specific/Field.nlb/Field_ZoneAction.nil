// License Information:
// src/Tricky Script/Script/Use/Specific/Field.nlb/Field_ZoneAction.nil
// Version: 19.12.30
// Copyright (C)  Jeroen Petrus Broks
// 
// ===========================
// This file is part of a project related to the Phantasar Chronicles or another
// series or saga which is property of Jeroen P. Broks.
// This means that it may contain references to a story-line plus characters
// which are property of Jeroen Broks. These references may only be distributed
// along with an unmodified version of the game.
// 
// As soon as you remove or replace ALL references to the storyline or character
// references, or any termology specifically set up for the Phantasar universe,
// or any other univers a story of Jeroen P. Broks is set up for,
// the restrictions of this file are removed and will automatically become
// zLib licensed (see below).
// 
// Please note that doing so counts as a modification and must be marked as such
// in accordance to the zLib license.
// ===========================
// zLib license terms:
// This software is provided 'as-is', without any express or implied
// warranty.  In no event will the authors be held liable for any damages
// arising from the use of this software.
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// End License Information



#use "Script/Use/Anyway"
#use "Libs/LinkedList"
#use "Libs/KettingKaart"
#accept FlowField

var ZAXPand(t, i)
	i = i or 1
	if t[i] ~= nil then
		return t[i], ZAXPand(t, i + 1)
	end
end

bool KettingInitDone

class ZoneAction

	static table List

	static void RoomChange(int inc,string exitpoint)
		string cLay
		var nLay
		cLay = Map.Layer
		assert(prefixed(cLay,"#"),"Next/Prev only works for rooms prefixed with a #")
		assert(#cLay==4,"Invalid Next/Prev length!")
		nLay = tonumber(right(cLay,3))
		assert(nLay,"Numberic parsing error for Next/Prev ("..cLay..")")
		FlowField.Map.Kthura.Layer = sprintf("#%03d",nLay + inc)
		Map.SpawnPlayer(exitpoint)
	end
	
	static var AltNext
	
	static void LoadAltNext(string anf)
		self.AltNext = NIL.Use('Script\Use\Specific\FieldModules\ZoneAction'..anf)
		self.AltNext.Init() // Required as some setting may have to be reloaded, after all!
	end
	
	static void NextRoom()
		if self.AltNext and (self.AltNext[".hasmember"]("NextRoom"))
			self.AltNext.NextRoom()
			return
		end
		$RoomChange( 1,"Start")
	end
	
	static void PrevRoom()
		if self.AltNext and (self.AltNext[".hasmember"]("PrevRoom"))
			self.AltNext.PrevRoom()
			return
		end
		$RoomChange(-1,"Einde")
	end
	
	static void Reset()
		$List = $List or {}
		$List.Enter = $List.Enter or new TLinkedList
		$List.Leave = $List.Leave or new TLinkedList
		$List.Cycle = $List.Cycle or new TLinkedList
		for k,v in pairs($List) 
			v.Clear()
		end
		
		new ZoneAction("Enter","Next",ZoneAction.NextRoom)
		new ZoneAction("Enter","Prev",ZoneAction.PrevRoom)
		new ZoneAction("Enter","Delisto",WorldMap.Delisto)
		new ZoneAction("Enter","Aeria",WorldMap.Aeria)
		new ZoneAction("Enter","Dyrt",WorldMap.Dyrt)
		new ZoneAction("Enter","CatIsland",WorldMap["Cat-Island"])
	end
	
	string ActEvent
	string ActZone
	table ActParams
	var Act
	
	get string ActType
		return type($Act)
	end
	
	bool WasInZone
	bool WordtInZone
	
	static table CheckDels
	
	static void InitCheckDels()
		if $CheckDels.Enter 
			return
		end
		$CheckDels.Enter = { ['Was'] = false, ['Wordt'] = true  }
		$CheckDels.Leave = { ['Was'] = true,  ['Wordt'] = false }
		$CheckDels.Cycle = { ['Was'] = true,  ['Wordt'] = true  }
	end
	
	static bool CheckAll()
		bool ret = false
		for Event,ZoneList in pairs($List)
			for Zone in ZoneList.Each
				Zone.WordtInZone = FlowField.Map.Kthura.Actor.Player.IsInZone(Zone.ActZone)
				if Zone.WordtInZone == $CheckDels[Event].Wordt and Zone.WasInZone == $CheckDels[Event].Was
					switch Zone.ActType
						case "function" "delegate"
							Zone.Act(ZAXPand(Zone.ActParams))
							ret=true
						default
							error("No action setup yet for ActType: "..Zone.ActType)
					end
				end
				Zone.WasInZone = Zone.WordtInZone
			end
		end
		return ret
	end
	
	void CONSTRUCTOR(string Event,string Zone,AAct,infinity)
		self.InitCheckDels()
		self.ActEvent = Event
		self.ActZone = Zone
		self.Act = AAct
		self.ActParams = { infinity }
		self.List[Event].AddLast(self)
		CSayF("%s event created in zone %s",Event,Zone)

		if not KettingInitDone
			KettingKaart.ZA_Enter = void(string Zone,Action,infinity)
				new ZoneAction("Enter",Zone,Action,infinity)
			end
			KettingKaart.GoToLayer = Map.GoToLayer
			KettingInitDone = true
		end

	end
	
	void DESTRUCTOR()
		CSayF("%s event disposed in zone %s",self.ActEvent,self.ActZone)
	end
	
end
