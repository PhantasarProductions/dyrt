#use "libs/xmath"

group RENC
	
	var Swords
	int MapTravelLevel
	int MaxEncounters
	int Encounters
	int DecRate
	int Rate
	int MaxRate
	
	int gx 
	int gy
	int gdeg
	bool ManEncOn = true
	bool AutEncOn = true
	
	readonly table bcol
	
	void CONSTRUCTOR()
		self.Swords = LoadImage("gfx/RENC/Swords.png")
		self.gx = Screen.Width + 25
		self.gy = Screen.Height - 128 - 100 - 20
		setmetatable(self.bcol,{
			["__index"] = var(myself,int key)
				number r
				r = math.ceil(key/$MaxRate)*4)
				switch r
					case 0 1
						return 255,0,0
					case 2
						return 255,180,0
					case 3
						return 0,255,0
					default
						return 0,0,255
				end
			end,
			['__newindex'] = void()
				error("Read-Only value overwritten!")
			end
		})
	end
	
	void Recalc()
		int XEnc
		if ($MapTravelLevel>__travellevel + (3-__skill)
			XEnc = ($MapTravelLevel - ( __travellevel + (3-__skill) )) * __skill
		end
		$MaxEncounters = (MaxE or 5) + XEnc
		$DecRate = 1 + XEnc
		$Rate = 20
	end
	
	void Reset(int MapTLevel,MaxE)
		$MapTravelLevel = MapTLevel
		$Recalc()
		$Encounters = $MaxEncounters
		$ManEncOn = true
	end
	
	void Gauge()
		int r
		int g
		int b
		number s
		number bar
		if AutEncOn and $gx > Screen.Width-50
			$gx--
		elseif (not AutEncon) and $gs < Screen.Width + 25
			$g++
		end
		if ManEncOff
			GraphColor = 100
		end
		__white
		Rect($gx-1,$gy-1,12,102)
		__black
		Rect($gx,$gy,10,100)
		$gdeg++
		if $gdeg>=360
			$gdeg = $gdeg - 360
		end
		r,g,b = $bcol[$Rate]		
		bar = math.floor( ($Rate/$MaxRate) * 100)
		for ix=0,10
			// math.sin counts in radians, but for this particular calcuation I need degrees, and xmath.sin counts in that.
			s = math.abs(xmath.sin(ix+$gdeg))
			Color(math.ceil(s*r),math.ceil(s*g),math.ceil(s*b))
			// Cheap way to draw a straight line. No need to use Bresenham here, as that would slow things down in THIS particular case.
			Rect($gx+ix,$gy+(100-bar),1,bar)
		end
	end

end
